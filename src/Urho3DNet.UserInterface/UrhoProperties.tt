<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)Urho3DNet.dll" #>
<#@ assembly name="NetStandard" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Urho3DNet" #>
<#@ output extension=".cs" #>
using Urho3DNet.MVVM.Binding;

namespace Urho3DNet.MVVM
{
<# Action<string, string, Tuple<string,Type>[]> PrintPropertiesForClass = (name, baseName, properties) => { #>
    public partial class <#=name#>View : <#=baseName#>View
    {
        private <#=name#> _target;

<# foreach (var property in properties) {
    var propertyName = property.Item1;
    var propertyType = property.Item2;
    var propertyTypeName = propertyType.Name;
    if (propertyType == typeof(float))
        propertyTypeName = "float";
    else if (propertyType == typeof(bool))
        propertyTypeName = "bool";
    else if (propertyType == typeof(string))
        propertyTypeName = "string";
    else if (propertyType == typeof(int))
        propertyTypeName = "int";
#>
        #region Property <#=propertyName#>

        private <#=propertyTypeName#> _lastKnown<#=propertyName#>;

        public static readonly DirectProperty<<#=name#>View, <#=propertyTypeName#>> <#=propertyName#>Property =
            UrhoProperty.RegisterDirect<<#=name#>View, <#=propertyTypeName#>>(
                nameof(<#=propertyName#>),
                o => o.<#=propertyName#>,
                (o, v) => o.<#=propertyName#> = v);

        public <#=propertyTypeName#> <#=propertyName#>
        {
            get => _target.<#=propertyName#>;

            set
            {
                SetAndRaise(<#=propertyName#>Property, _lastKnown<#=propertyName#>, value, _ =>
                {
                    _lastKnown<#=propertyName#> = value;
                    _target.<#=propertyName#> = value;
                });
            }
        }

        #endregion Property <#=propertyName#>
<# } #>
    }
<# };


PrintPropertiesForClass("Slider", "BorderImage", new Tuple<string,Type>[]{
    Tuple.Create("Orientation", typeof(Orientation)),
    Tuple.Create("Range", typeof(float)),
    Tuple.Create("Value", typeof(float)),
    Tuple.Create("RepeatRate", typeof(float)),
});
PrintPropertiesForClass("BorderImage", "UIElement", new Tuple<string,Type>[]{
//    Tuple.Create("Texture", typeof(Texture)),
    Tuple.Create("ImageRect", typeof(IntRect)),
    Tuple.Create("Border", typeof(IntRect)),
    Tuple.Create("ImageBorder", typeof(IntRect)),
    Tuple.Create("HoverOffset", typeof(IntVector2)),
    Tuple.Create("DisabledOffset", typeof(IntVector2)),
    Tuple.Create("BlendMode", typeof(BlendMode)),
    Tuple.Create("IsTiled", typeof(bool)),
    Tuple.Create("Material", typeof(Material)),
//    Tuple.Create("TextureAttr", typeof(ResourceRef)),
//    Tuple.Create("MaterialAttr", typeof(ResourceRef)),
});
PrintPropertiesForClass("UIElement", "Animatable", new Tuple<string,Type>[]{
    Tuple.Create("Name", typeof(string)),
    Tuple.Create("Position", typeof(IntVector2)),
    Tuple.Create("Size", typeof(IntVector2)),
    Tuple.Create("Width", typeof(int)),
    Tuple.Create("Height", typeof(int)),
    Tuple.Create("MinSize", typeof(IntVector2)),
    Tuple.Create("MinWidth", typeof(int)),
    Tuple.Create("MinHeight", typeof(int)),
    Tuple.Create("MaxSize", typeof(IntVector2)),
    Tuple.Create("MaxWidth", typeof(int)),
    Tuple.Create("MaxHeight", typeof(int)),
    Tuple.Create("ChildOffset", typeof(IntVector2)),
    Tuple.Create("HorizontalAlignment", typeof(HorizontalAlignment)),
    Tuple.Create("VerticalAlignment", typeof(VerticalAlignment)),
    Tuple.Create("EnableAnchor", typeof(bool)),
    Tuple.Create("MinAnchor", typeof(Vector2)),
    Tuple.Create("MaxAnchor", typeof(Vector2)),
    Tuple.Create("MinOffset", typeof(IntVector2)),
    Tuple.Create("MaxOffset", typeof(IntVector2)),
    Tuple.Create("Pivot", typeof(Vector2)),
    Tuple.Create("ClipBorder", typeof(IntRect)),
    Tuple.Create("Priority", typeof(int)),
    Tuple.Create("Opacity", typeof(float)),
    Tuple.Create("BringToBack", typeof(bool)),
    Tuple.Create("ClipChildren", typeof(bool)),
    Tuple.Create("UseDerivedOpacity", typeof(bool)),
    Tuple.Create("IsEnabled", typeof(bool)),
    Tuple.Create("IsEditable", typeof(bool)),
    Tuple.Create("IsSelected", typeof(bool)),
    Tuple.Create("IsVisible", typeof(bool)),
    Tuple.Create("IsHovering", typeof(bool)),
    Tuple.Create("IsInternal", typeof(bool)),
    Tuple.Create("FocusMode", typeof(FocusMode)),
    Tuple.Create("DragDropMode", typeof(DragAndDropMode)),
    Tuple.Create("LayoutMode", typeof(LayoutMode)),
    Tuple.Create("LayoutSpacing", typeof(int)),
    Tuple.Create("LayoutBorder", typeof(IntRect)),
    Tuple.Create("LayoutFlexScale", typeof(Vector2)),
//    Tuple.Create("Tags", typeof(StringList)),
    Tuple.Create("Indent", typeof(int)),
    Tuple.Create("IndentSpacing", typeof(int)),
    Tuple.Create("TraversalMode", typeof(TraversalMode)),
    Tuple.Create("IsElementEventSender", typeof(bool)),
});
PrintPropertiesForClass("Animatable", "Serializable", new Tuple<string,Type>[]{
    Tuple.Create("AnimationEnabled", typeof(bool)),
//    Tuple.Create("ObjectAnimation", typeof(ObjectAnimation)),
//    Tuple.Create("ObjectAnimationAttr", typeof(ResourceRef)),
});
PrintPropertiesForClass("Serializable", "Object", new Tuple<string,Type>[]{
    Tuple.Create("IsTemporary", typeof(bool)),
});


#>
}